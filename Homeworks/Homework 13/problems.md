**Source: https://www.hackerrank.com/contests/sda-hw-13-2022/challenges**

**Task 1:**

Супер Хамилтън е най-храбрият рицар в царството Алгоритмия и му е зададена много сложната задача да спаси принцесата на кралството от лабиринта на злия Сесий. За да се отключи вратата на принцесата са необходими да се съберат K на брой ключа, като всички ключове са разпръснати по 1 във всяка стая на лабиринта. Проблемът е че след като се посети една стая, тя се заключва за винаги и не може да бъде посетена втори път.

Намерете броя на възможните начини Хамилтън да стигне до принцесата. Ако не може да стигне, възможните начини са 0.

За улеснение лабиринтът представлява матрица, която има 4 вида символи:

- - е стая, чиите ключ трябва да вземем
- x е непроходима стая (в нея няма ключ и не може да влезем)
- s е началната позиция на Супер Хамилтън (може да е на произволно място в лабиринта)
- e е стаята на принцесата, която Супер Хамилтън трябва да спаси

От всяка стая (s или -) може да отидем единствено в стаите на ляво/дясно/горе/долу, ако такива съществуват. Не може да се движим по диагонал и не може да напускаме лабиринта.

*Input Format:*

На първия ред получавате 2 числа rows, cols  които са съответно размера на лабиринта (редове и колони)

На следващите rows реда ще получите по cols символа. Какво означава всеки символ е описано по-горе.

*Constraints:*

0 <= rows x cols <= 25


**Task 2:**

Времето за търсене на възел в дърво зависи от дълбочината му. За това е добре да минимизираме дълбочината на дърветата, с които работим. Имплементирайте алгоритъм, който да намира оптималния връх/върхове в дадено дърво, така че да се минимизира дълбочината на дървото.

Дървото, което ще получите няма фиксиран брой деца и не е дърво за търсене. Единствено се изисква да намерите върха/върховете, който ако бъде избран за корен ще минимизира дълбочината на цялото дърво.

*Input Format:*

На първият ред ще получите N - броя на върховете в дървото.

На следващите N-1 реда ще получите по една двойка числа a, b, които обозначават, че връх a е свързан с връх b. Може да си мислите, че това са ребра в ненасочен граф, тъй като не ни интересува дали a е родител или дете на b накрая.

*Output Format:*

На един ред изведете всички върхове, които ако станат корен ще минимизират дълбочината на дървото. Върховете да са подредени в нарастващ ред.


**Task 3:**

Известният математик Ойлер искал да мине през всички мостове на Кьонигсберг, без да минава през някой мост 2 или повече пъти. От там се ражда и известният проблем за Ойлеров цикъл и Ойлеров път, като това са обхождания на граф така, че всяко ребро се посещава точно по 1 път.

Вашата задача е по подаден граф да определите дали Ойлер може да обходи всяко ребро в графа точно по веднъж и ако да - дали накрая ще се върне във върха, от където е тръгнал, или не.

ЗАБЕЛЕЖКА: Ойлер трябва да може да посети всички върхове на графа, не е достатъчно подграф да съдържа Ойлеров цикъл/път.

Важно е да отбележим, че графът може да е мултиграф.

*Input Format:*

Нап първият ред ще получите 1 число queries - броя на заявките, които ще получите.

След това queries пъти ще получите:

На първия ред N M - 2 числа, съответно броя на върховете и броя на ребрата в даден граф.

На следващите M реда ще получите по 2 числа a b, които дефинират ребро между върха a и върха b за графа описан на горния ред.

*Output Format:*

За всяка една заявка изведете едно от следните 3 на нов ред:
- none, ако графът не е нито Ойлеров път, нито Ойлеров цикъл
- epath, ако графът има Ойлеров път
- ecycle, ако графът има Ойлеров цикъл

Ойлеров цикъл е по-силен от Ойлеров път. т.е ако има цикъл е гарантирано, че има и път, но изведете, че има цикъл, тъй като това дава повече информация.
