**Source: https://www.hackerrank.com/contests/sda-hw-8-2021/challenges**

**Task 1:**

Алгоритмия e станала много елитна държава и всеки ден населението й расте! Държавният глава се интересува от гражданите си и наема статистици да следят за различни показатели на населението.

Един показател, който иска да знае е медиана на състоянието. Това е число, което разделя населението на две равни части - едната част има повече пари в сметката си, от това число, а другата по-малко.

Бивайки много популярна държава, следенето на този показател е трудно, тъй като всеки ден нов гражданин се преселва в Алгоритмия. Помогнете на статистиците като след всеки нов регистриран гражданин отпечатате на стандартния изход медианата.

*Input Format:*

Първият ред на стандартния вход съдържа едно цяло число N (брой граждани).

Следват N на брой цели положителни числа, всяко на нов ред (парите на поредния гражданин).

*Output Format:*

След всеки регистриран гражданин, отпечатайте на нов ред на стандартния изход обновената статистика с точност до първия знак след десетичната запетая (с точност до 10^(-1)).


**Task 2:**

В един щастлив ден се оказвате собственик на магазин за баници. Един ден получавате N на брой поръчки за баници, всяка от които започва във време t[i] и за изпълнението и ще отнеме време f[i], където i е номера на поръчката. Магазинът ви обаче има политика да обслужва най-бързата за приготвяне и ще я довърши изцяло преди да се заеме с нова поръчка. В същия момент като приключите поръчката, взимате нова и започвате да я изпълнявате

Забележка: Ако в един момент има повече от 1 поръчка, която е най-бърза за приключване, Сашко иска да започне с тази, която е била подадена първа (тази която е била най-рано във входа).

*Input Format:*

На първия ред на стандартния вход ще получите броя на поръчките N На следвашите N реда ще получите по две числа t[i] и f[i], съответно времето от което нататък включително ще може да се започне поръчката и колко време ще отнеме за изпълнение i-тата поръчка (i e номера на реда, като номерацията започава от 0)

*Constraints:*

1 <= N <= 10^5 1 <= t,f <= 10^9

*Output Format:*

На стандартния изход изкарайте реда, в който поръчките ще се свършат от магазина. Индексите в реда на изпълнение разделени с интервал.


**Task 3:**

След поредното онлайн контролно при Ч², Ч² е обещал да провери контролните на всички веднага. Дори е решил, че ако някой предаде по-рано, то Ч² веднага ще започне да проверява, за да не губи време. Ч² обаче иска да проверява така че средното време за чакане за проверка на всички да е минимално, за да не се сърди никой, че е останал последен. Ч² проверява 1 ред код за 1 секунда.

Намерете минималното средно време, което трябва да чака един студент, за да му бъде проверено контролното.

Забележка: Ч² не може да вижда бъдещето, така че ако не проверява на никого и някой студент предаде контролно Ч² започва веднага да проверява. Това предполага че може в следващият момент да бъде предадено по-удачно за проверяване контролно, но Ч² няма как да знае за него.

*Input Format:*

На първият ред ще получите едно число N- броя на студентите.

На следващите N реда ще получите по 2 числа: 
submitTime_i, submitTime_i  за всеки студент, където
- submitTime_i е времето когато i-тия студент предава контролното, а
- submitTime_i е колко реда код е предал

Забележка: Студентите на входа не са подредени.

*Output Format:*

На 1 ред изведете единствено число: Минималното средно време, което всеки студент трябва да чака, за да му бъде проверено контролното. Отговорът закръглете на долу до цяло число.


**Task 4:**

Като тийм лидер в кол център искате да разберете кои ваши подчинени успяват да помогнат на най-много клиенти в един ден. Операторите са k на брой като индексацията започава от 0. Има няколко правила по който се обслужват клиентите:

1. Всяко позвъняване на клиент i се определя от две цели положителни числа t[i] и l[i], съответно момента в който човека се е обадил и колко време ще отнема да бъде обслужен. i започва от 0.

2. Ако (i%k)-тия оператор е свободен той ще обслужи клиента.

3. Ако (i%k)-тия оператор е зает ще се пробвате да бъде обслужен от следващия подред свободен оператор, докато не стигнете k-1. Ако и той е зает ще се пробвате с оператор 0 и тези след него докато не стигнете (i%k)-тия отново, ако всички опертори за заети.

4. Ако всички оператори са заети в този момент на човека ще бъде автоматично затворено и няма да бъде обслужен.

Забележка: Ако i%k = 0, то се взема последния оператор.

Клиентите се обаждат в строго нарастваш ред, което означава че за всяко i и j, където i < j, то t[i] <= t[j]. Това не е задължително вярно за l[i] и l[j].

Намерете индекса наоператора, който е обслужил най-много клиенти. Ако са няколко с максималния брои изкарайте индексите им сортирани в нарастваш ред.

*Input Format:*

На първия ред на стандартния вход ще получите две цели числа N и K, съответно броя на клиентите и броя на операторите. На следващите N на брой реда ще получите по 2 цели положителнио числа. Съответно времето, в което ще се обади килиета и колко време ще отнеме да се обслужи

*Constraints:*
1 <= K <= 10^5 1 <= N <= 10^5 1 <= t[i], l[i] <= 10^9

*Output Format:*

На един ред на стандартния изход изведете индексите на операторите, които са обслужили най-много клиенти разделени с интервал сортирани в нарастващ ред.
